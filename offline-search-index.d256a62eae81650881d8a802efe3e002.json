[{"body":" この記事はR3ブログから翻訳されています。英文オリジナルの記事はこちら。\n CordaのFlowは、KotlinまたはJavaを用いて、分岐のない一連のないプログラムとして記述できます。しかし、実行時には多くの分岐や補完的な動作が発生します。例えば・・\n Checkpointでの状態保存（障害耐性確保の為） SubFlowの実行 他のノードへのメッセージ送信とその後の受信待機 非同期呼び出しと、その結果待ち  等です。\nCordaは、Quasar fiber をベースにしたState Machine上で動作することで、こうした分岐／補完動作を実現しています。\nこの記事は、こうした動作の概要を説明することが目的です。動作を理解することで、Cordaノードの運用を行うにあたっての基礎になると考えます。\n注意事項 概念の説明を中心に行っていて、エラー処理を無視しています。Cordaのステートマシン/フローフレームワーク/ P2Pメッセージングに実際に変更を加える場合は、もう少し詳細を理解する必要があります。技術的詳細についてはCordaの英文ドキュメントサイトをご覧ください。 現在の実装に基づいて説明していますが、将来変更される可能性があります。CorDappを作成する場合は、公式のドキュメントとAPIに基づいて設計してください。ドキュメントを理解する助けとなる事がこの記事の目的であって、技術的な代替手段を検討するためのものではありません。\nQuasarとは？ Quasarは、Javaバイトコードの巧妙な書き換えと例外を利用して、継続（contiuation、情報処理用語でプログラムの実行に関して、ある時点で中断され、評価されていない残りのプログラムを再度実行する機能を指す）を提供するJavaライブラリです。\nQuasarにおけるもっとも重要な概念はfiberです。fiberとは、プログラムコードにおけるスレッドのようなものですが、fiberは自らを一時停止できます。その時点で、その計算状態を保存することができます。保存された状態を元に戻し、そこから再び計算を始めることができます。\nさて、この機能を実現する仕組みをまずは学びましょう。\nユーザーは，中断可能であるすべての関数に対して@Suspendableというアノテーションをつける必要があります。起動時とJITコンパイルの直前に、Quasarは，@Suspendableメソッドのバイトコードを書き換えます。具体的には、throws SuspendExecutionを関数定義に追加し,全てのcatchブロックに、SuspendExecutionを再スローするコードを追加します。この例外をユーザーコードでキャッチさせないためです。\nfiberを中断するために、プログラムはQuasarの特定の関数（例えば?parkAndSerialize）を呼び出します。この関数はSuspendExecutionを投げ、投げられたこの例外はすべてのユーザーコードを通過し、Quasarによってキャッチされます。Quasarは、コールスタックを抽出し、シリアライズして保存します。バイトコードインストゥルメンテーション（byte code instrumentation）は、コールスタック上の関数が使用する変数、ローカルオブジェクト、スレッドが使用しているローカルストレージ等の値を全て確保でき、fiberはこのひと固まりのスレッドを再構成することができます。また、これらすべてをメモリに保存した後、CPUは現在の実行スレッドを解放するので、CPUは他の何かを実行するためにこの実行スレッドを利用可能になります。\nファイバーを復元すると、コールスタックが新しいスレッドで再作成され、すべての値が記録されたとおりに関数に渡され、スレッドのローカルストレージが復元され、停止したところから実行が続行されます。\nこれを機能させるには、中断するスタック内のすべての関数に@Suspendableアノテーション付けて、クエーサーがそれらを計測できるようにすることが重要です。そうしないと、例外がキャッチされるか、パラメーターが正しくキャプチャされず、fiberが正しく中断されません。これは、CorDappsのエラーの一般的な原因（transaction context missingエラーなど）であり、スタックのどの関数に注釈が欠けているかを把握するのは非常に難しい場合があります。\nCordaのFlowはQuasarをラップし、それを使用して、CorDappのflow logic実装に含まれるKotlinまたはJavaのコードを、一時停止可能なコードに変換します。一時停止可能だと指定した場所をcheckpointと呼び、システムは任意のcheckpointからコードを再実行できる事が保証されます。\nFlowの状態遷移 さて、FlowがCheckPointで中止＆再開できる仕組みを見てきたところで、次にFlowの状態遷移についてみていきましょう。FlowはQuasarによる一時停止機能がある事を前提に、次のような状態遷移を想定しています。\nまず、すべてのフローはPending状態から始まります。次にrunningに移行します。最も簡単なケースでは、最終的にコードの最後に到達してsuccessに移行し、結果が返されます。コード途中で指定され、保存されていたCheckPointは全て消去されます。\nエラーが発生した場合はErroedに移行し、FlowHospitalが管理することになります。FlowHospitalでは3つの可能性があります。\n一時的なエラーの場合、Pendingに戻って再実行されます。この時、Flowは最初から実行されるのではなく、記録された最後のチェックポイントから再試行されます。 エラーが致命的である場合、フローは失敗Failedとして終了します。エラーが呼び出し元に返され、すべてのCheckPointが削除されます。 エラーを単純に再試行することはできないが、失敗させることができない場合（たとえば、元帳の整合性が失われる可能性がある場合など）、Flowはheld状態に移行します。hold状態の解消には、次のような人間の介入が必要です。 エラーの原因となった状態を修正する。 最後のCheckPointから手動でフローを再開する。（現状、これはNodeの再起動によって実現します。将来のリリースでRPCによる再開が実装される予定です）\nFlowのライフサイクル Flowのライフサイクルを考えるとき、Cordaノードを「ユーザースペース」と「カーネルスペース」に分けて考えると便利です。「ユーザースペース」は、ユーザーが提供するFlow logicを実行し、「カーネルスペース」は、ユーザーの提供するコードを実行するFlowフレームワークです。\n典型的なフローはあるスレッドで実行が開始され、ネットワーク上の他のノードに送付され、帰ってきたレスポンスを受けて再開するという流れをたどります。この流れの詳細を確認していきましょう。\n![image]/docs/images/understanding_corda/corda-state-machine-3.png)\n1. Flowの開始 RPCを介してFlowがキックされると、StartFlowがカーネルスペースで呼び出されます。これにより、Flowを開始するイベントがスケジュールされます（RPC処理とメッセージのデシリアライズ処理は別のスレッドプールで行われることに注意してください）CPUの実行スレッドが使用可能になるとすぐに、メッセージの処理を開始し、FlowはPendingからRunningに移行します。この作業には以下の作業も含まれます。\nスレッドを取得する。 データベース接続を取得して（fiberを保存するための）トランザクションを開く。 CorDappから要求されたFlowLogicをインスタンス化し、必要なパラメータを渡す。 FlowLogicのrun関数を呼び出す。\n2. 実行と一時停止 次に、ユーザーコードは、一時停止が必要なポイントに到達するまで実行されます。一時停止の最も一般的な条件は次のとおりです。\nメッセージを送信した場合 FlowLogic.sleep()の呼び出し。つまり、明示的に一定時間Flowを一時停止する場合 Flow非同期API（FlowLogic.await()）の使用\nここでは、Flowが他の一つのノードとsendAndReceive()を用いて通信する。この関数はカーネル空間を呼び出し、次のことを行います。\nペイロードをシリアル化して、この関数に渡します。 メッセージを送信キューに入れると、P2Pメッセージングシステムによってピックアップされます。（P2PメッセージングシステムArtemisは、それだけで一つの記事が書けるほどのものです。ここでは、このシステムは頑健で、正確に1度だけメッセージを送信することができることだけを述べます。）このシステムによって、メッセージが正しく配信され（いずれ）返信を受け取ることができると想定できます。 次に、QuasarのparkAndSerialize関数を呼び出して、前節で示した通りコールスタック他の情報を記録します。 ノードはこのFlowに割り当てられたリソースの中で、Quasarが無視してしまう部分の後処理をする必要もあります。典型的には、開いているデータベーストランザクションをコミットして、データベース接続を解放する必要があります．他のリソース（ロックなど）も同様に処理する必要があります。これはCordaコードで行われます。 Cordaはまた、Checkpointでのコピーをデータベースに保存するため、中断されたフローも再起動することができます。 Kryoシリアライザーを使用するので、スタック上で見つかったものはすべてシリアル化できます。これは、RPCおよびP2P通信で使用されるシリアライザやStatesをデータベースに保存する際に使われるシリアライザとは異なる仕組みです。通信用やState用はその内容に制約や制限が必要ですが、CheckPoint用シリアライザは、すべてを受け入れる必要があります。一方で、データ形式や構造の変化に対処する必要はありません。 シリアルの際に無視する必要のあるもの（主にノードやState Machineそのものなどで、デシリアライズ処理時にも当然にメモリ上に存在するモノ）のリストがあります。 特定のクラス（Cordaサービスなど）はSerializeAsTokenインターフェースを実装していて、クラスインスタンスの代わりにトークン化したデータだけが記録されます。これらのクラスは、デシリアライズ処理の際にインスタンスを取得するメカニズムを別途指定する必要があります。特にシングルトンクラスをシリアライズする時に役立ちます。\nその後、fiberはRunningからSuspendedに移行し、CPUの実行スレッドは他のタスクを実行できるようになります。\n3. メッセージ受信と再開 送信したメッセージに対する応答メッセージが到着すると、P2Pメッセージングシステムは、fiberへ再起動を促すメッセージをイベントキューに置きます。CPUの実行スレッドが使用可能になると、中断されたfiberの状態遷移が次ようにして再開します。\nコールスタックと変数が再作成されます リソースが再取得されます（例えば，DB接続およびトランザクションが開かれます） 受信したメッセージはデシリアライズされます 受信メッセージは、Flowが再びSuspendedするか、終了したときにのみP2Pメッセージングシステム上から削除されます。何らかのエラーに伴うフェイルオーバーが起きた場合、フローはメッセージ送信直後のチェックポイントから再実行され、P2Pメッセージングキューからメッセージを再受信します。 次に、ユーザー空間のFlowLogicが、sendAndReceive を叩いた時点の状態で呼び出され、メッセージの内容を関数呼び出しの戻り値として渡します。\n4. 実行完了 FlowLogicが最後まで正常に完了すると、制御はカーネル空間に戻り、次の処理が行われます。\nデータベーストランザクションがコミットされます このフローのすべてのCheckPointがデータベースから削除されます。 P2Pメッセージングシステムに保存されていた未処理のメッセージはキューから削除されます。 関数戻り値はRPCプールに渡されます。シリアル化されて呼び出し元のクライアントに送り返すことになります。 データベース接続が解放され、fiberが終了し、CPUの実行スレッドが解放されます。\n含意 この上記の実装は、CorDappsの開発者にいくつかの影響を与えます\n  別途、生のJDBC接続を張りに行っても通常のACIDデータベースロジックをCorDappsで単純に使用することはできません。\n  Flow logic中で、DBを単純にコミットすることはできません（FlowLogic.sleep(1.millis)は妥当で現実的な回避策です）\n  一時停止により、想定外のDBコミットが発生する可能性があります。\n  Flowが失敗した場合、DBトランザクションはロールバックされます。使用しているJDBC接続で別途何かを行った場合、それは失われます。再試行すると、フローは最後のメッセージから再開されるため、DBトランザクションが再発生します。\n  DBトランザクションをロールバックすることはできません。FlowLogic内はFlowベースのトランザクション内にいるためです。SQLコードを直接記述して何か問題が発生し、ロールバックした場合、元帳の整合性が脅かされる可能性があります\n    Flowのすべての部分が少なくとも1回実行されます。ただし、問題が発生した場合、最後のCheckpointからエラーが発生したポイントの間の部分が再実行されます。Flowは、ロールバックを介して発生するすべてのDBトランザクションをクリアしてクリーンに再実行できるようにしますが、サードパーティコンポーネントとの他のやり取りは、べき等であるか、複数回の呼び出しを処理できる必要があります。\n  @Suspendableアノテーションは、非常に注意深く使用なければなりません。@Suspendable ではない関数から、@Suspendableな関数を呼ぶことはできません。（逆は問題はありません。@Suspendable な関数からデータベース操作などの@Suspendableではない関数を呼び出すことは可能です。） バイトコードのスキャン/再読み込みは、かなり時間がかかります。サスペンド操作は安価ではありません。 バイトコードインストゥルメンテーション（byte code instrumentation）がうまくできないコードを書いてしまう事があります。（例えば、Kotlinの?.map{}操作内で@Suspendable関数を使用する等）この場合、再生成されるバイトコードが無効化され、JVMが実行時にあきらめる可能性があります。これはKotlinの既知の問題であり、この問題が発生した場合、以下のようなコンパイルオプションを指定することで改善できます。   compileKotlin { kotlinOptions { freeCompilerArgs = [\"-Xnormalize-constructor-calls=enable\"] } } ","excerpt":" この記事はR3ブログから翻訳されています。英文オリジナルの記事はこちら。\n CordaのFlowは、KotlinまたはJavaを用いて、分 …","ref":"/docs/understanding_corda/general_concepts/corda-state-machine/","title":"Corda State Machine 概要"},{"body":"","excerpt":"","ref":"/tags/cordapp/","title":"cordapp"},{"body":"","excerpt":"","ref":"/tags/state-machine/","title":"state machine"},{"body":"","excerpt":"","ref":"/tags/","title":"Tags"},{"body":"  #td-cover-block-0 { background-image: url(/city-background_huae6985e655e9c46a6a5d2b97bb64b2d8_451445_960x540_fill_q75_catmullrom_bottom.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/city-background_huae6985e655e9c46a6a5d2b97bb64b2d8_451445_1920x1080_fill_q75_catmullrom_bottom.jpg); } }  Welcome to Corda Guide記事 読む           Cordaに関する最新の技術情報を記事にして発信を行っています。 全てのレポートはサポートページ(Corda Guide)の「ドキュメント」または「リリースノート」をご覧ください。\n      ドキュメンテーション 日本語で書かれたCordaに関する技術記事です。\n読む\n   Medium 記事一覧を作成しました。\n読む\n   Follow us on Twitter! For announcement of latest features etc.\n続きを読む …\n --   コミュニティ Cordaのコミュニティに参加する。\n参加しよう!\n    ","excerpt":"  #td-cover-block-0 { background-image: …","ref":"/","title":"Welcome to Corda Guide"},{"body":"","excerpt":"","ref":"/tags/bootstrap/","title":"bootstrap"},{"body":"","excerpt":"","ref":"/tags/docker/","title":"docker"},{"body":"Dockerformは、CordaノードをDockerコンテナのローカルに簡単にデプロイすることができます。\nこれは、Cordaのgradleプラグインが提供するタスクで、Network Bootstrapperが生成したアウトプットを使って、ブートストラップされたCordaネットワークを簡単に起動するために使用できるdocker-compose.ymlファイルを自動的に生成します。\nNetwork Bootstrapperの公式ドキュメントはこちらです。\nメリット  Network Bootstrapper（こちらでも説明しています）構築を簡略化できるdocker-compose.yamlを自動的に作成します。これにより手動での構築が不要になります。 Cordaノードとそのデータベースの両方のデプロイメントをより適切に制御できるようになります。 Kubernetesでも使用可能な公式Dockerイメージの使用方法を理解することができます。  ウォークスルー事例 ドキュメントには、Dockerformがどのように機能するかが非常によく説明されています。ここでは、R3のGitHubにあるCorDappのサンプルを見てみましょう。\nhttps://github.com/corda/samples-kotlin/tree/master/Features/dockerform-yocordapp .\nDockerformについてのドキュメントはこちら。\n build.gradleの新しいタスク  外部からSSHでDockerコンテナに接続するために必要な “sshdPort “を追加します  ノードに使用する公式Corda Docker Imageを宣言します 外部からSSHでDockerコンテナに接続するために必要な “sshdPort “を追加します    prepareDockerNodes “タスクを実行する ./gradlew prepareDockerNodesを実行すると、/build/nodesフォルダ内に以下のようなアウトプットが作成されます。\n docker-compose.yamlは、prepareDockerNodesタスクから取得した情報で自動的に生成されます。  以下は、docker-compose.yamlの内容です。Dockerのすべてのボリュームが、build/nodes内に生成されたフォルダに関連付けられています。\n外部データベースを追加する 上記の例ではH2データベースを使用していますが、他のデータベースを追加することも可能です。DockerformがDockerコンテナの作成を行います。PostgreSQLを使った例を見てみましょう。\nこちらの内容は、こちらのドキュメントにも記載されています。\n ドキュメントに記載されている手順が完了したら、./gradlew prepareDockerNodesを実行します。ここでは、出力とdocker-compose.yaml が更新されます。PostgreSQLのパラメータを設定した新しいサービスであるnotary-dbがあります。\nまた、Dockerformは上記のDocker Composeで使用されるPostgreSQLのDockerfileと、データベースを初期化するスクリプトも作成します。\n","excerpt":"Dockerformは、CordaノードをDockerコンテナのローカルに簡単にデプロイすることができます。\nこれは、Corda …","ref":"/docs/corda-4/developers/cordapp_development/docker-bootstrap/","title":"DockerComposeを使用したネットワークブートストラップする"},{"body":"Dockerformは、CordaノードをDockerコンテナのローカルに簡単にデプロイすることができます。\nこれは、Cordaのgradleプラグインが提供するタスクで、Network Bootstrapperが生成したアウトプットを使って、ブートストラップされたCordaネットワークを簡単に起動するために使用できるdocker-compose.ymlファイルを自動的に生成します。\nNetwork Bootstrapperの公式ドキュメントはこちらです。\nメリット  Network Bootstrapper（こちらでも説明しています）構築を簡略化できるdocker-compose.yamlを自動的に作成します。これにより手動での構築が不要になります。 Cordaノードとそのデータベースの両方のデプロイメントをより適切に制御できるようになります。 Kubernetesでも使用可能な公式Dockerイメージの使用方法を理解することができます。  ウォークスルー事例 ドキュメントには、Dockerformがどのように機能するかが非常によく説明されています。ここでは、R3のGitHubにあるCorDappのサンプルを見てみましょう。\nhttps://github.com/corda/samples-kotlin/tree/master/Features/dockerform-yocordapp .\nDockerformについてのドキュメントはこちら。\n build.gradleの新しいタスク  外部からSSHでDockerコンテナに接続するために必要な “sshdPort “を追加します  ノードに使用する公式Corda Docker Imageを宣言します 外部からSSHでDockerコンテナに接続するために必要な “sshdPort “を追加します    prepareDockerNodes “タスクを実行する ./gradlew prepareDockerNodesを実行すると、/build/nodesフォルダ内に以下のようなアウトプットが作成されます。\n docker-compose.yamlは、prepareDockerNodesタスクから取得した情報で自動的に生成されます。  以下は、docker-compose.yamlの内容です。Dockerのすべてのボリュームが、build/nodes内に生成されたフォルダに関連付けられています。\n外部データベースを追加する 上記の例ではH2データベースを使用していますが、他のデータベースを追加することも可能です。DockerformがDockerコンテナの作成を行います。PostgreSQLを使った例を見てみましょう。\nこちらの内容は、こちらのドキュメントにも記載されています。\n ドキュメントに記載されている手順が完了したら、./gradlew prepareDockerNodesを実行します。ここでは、出力とdocker-compose.yaml が更新されます。PostgreSQLのパラメータを設定した新しいサービスであるnotary-dbがあります。\nまた、Dockerformは上記のDocker Composeで使用されるPostgreSQLのDockerfileと、データベースを初期化するスクリプトも作成します。\n","excerpt":"Dockerformは、CordaノードをDockerコンテナのローカルに簡単にデプロイすることができます。\nこれは、Corda …","ref":"/docs/corda-5/developers/cordapp_development/docker-bootstrap/","title":"DockerComposeを使用したネットワークブートストラップする"},{"body":"Dockerformは、CordaノードをDockerコンテナのローカルに簡単にデプロイすることができます。\nこれは、Cordaのgradleプラグインが提供するタスクで、Network Bootstrapperが生成したアウトプットを使って、ブートストラップされたCordaネットワークを簡単に起動するために使用できるdocker-compose.ymlファイルを自動的に生成します。\nNetwork Bootstrapperの公式ドキュメントはこちらです。\nメリット  Network Bootstrapper（こちらでも説明しています）構築を簡略化できるdocker-compose.yamlを自動的に作成します。これにより手動での構築が不要になります。 Cordaノードとそのデータベースの両方のデプロイメントをより適切に制御できるようになります。 Kubernetesでも使用可能な公式Dockerイメージの使用方法を理解することができます。  ウォークスルー事例 ドキュメントには、Dockerformがどのように機能するかが非常によく説明されています。ここでは、R3のGitHubにあるCorDappのサンプルを見てみましょう。\nhttps://github.com/corda/samples-kotlin/tree/master/Features/dockerform-yocordapp .\nDockerformについてのドキュメントはこちら。\n build.gradleの新しいタスク  外部からSSHでDockerコンテナに接続するために必要な “sshdPort “を追加します  ノードに使用する公式Corda Docker Imageを宣言します 外部からSSHでDockerコンテナに接続するために必要な “sshdPort “を追加します    prepareDockerNodes “タスクを実行する ./gradlew prepareDockerNodesを実行すると、/build/nodesフォルダ内に以下のようなアウトプットが作成されます。\n docker-compose.yamlは、prepareDockerNodesタスクから取得した情報で自動的に生成されます。  以下は、docker-compose.yamlの内容です。Dockerのすべてのボリュームが、build/nodes内に生成されたフォルダに関連付けられています。\n外部データベースを追加する 上記の例ではH2データベースを使用していますが、他のデータベースを追加することも可能です。DockerformがDockerコンテナの作成を行います。PostgreSQLを使った例を見てみましょう。\nこちらの内容は、こちらのドキュメントにも記載されています。\n ドキュメントに記載されている手順が完了したら、./gradlew prepareDockerNodesを実行します。ここでは、出力とdocker-compose.yaml が更新されます。PostgreSQLのパラメータを設定した新しいサービスであるnotary-dbがあります。\nまた、Dockerformは上記のDocker Composeで使用されるPostgreSQLのDockerfileと、データベースを初期化するスクリプトも作成します。\n","excerpt":"Dockerformは、CordaノードをDockerコンテナのローカルに簡単にデプロイすることができます。\nこれは、Corda …","ref":"/docs/developers/cordapp_development/docker-bootstrap/","title":"DockerComposeを使用したネットワークブートストラップする"},{"body":"","excerpt":"","ref":"/tags/security/","title":"security"},{"body":"CorDappの開発において、アップグレードは避けられません。CorDappのライフサイクルの間に、バグフィックスやビジネス要件の変更によるアップデートがないことはほとんどありません。アップグレードは小さなものもあれば、大規模な計画を必要とする複雑な変更の場合もあります。いずれにしても、これは見過ごせないテーマです。\n読み進める前に、この記事はステート、フロー、コントラクトなどのCordaの主要な概念を基本的に理解していることを前提としています。これらを理解していなければ、この記事の残りの部分はあまり意味をなさないので、まずはそれらに慣れることをお勧めします。\nExplicitおよびImplicitなContractのアップグレード Cordaでは、アップグレードを管理する方法が2つあります:\n Explicit(明示的): すべてのノードで同じバージョンのコントラクトを持つCorDappsを動作させる必要があります。 Implicit(暗黙的): それぞれのノードが異なるタイミングでアップグレードできるようにすることで  Explicit(明示的) なアップグレードのコンセプトはとても簡単です。基本的にアップグレードが必要なときは、すべてのノードがそれを行う必要があります。Explicitアップグレードの欠点は、すべてのノードが、アップグレードされるコントラクトに属する元帳の既存の状態をすべて更新する必要があることです。これは重い処理になります。また、Cordaのような分散型台帳システムでは、すべてのノードに同時にアップグレードを要求することができない場合もあります。\n一方、Implicit(暗黙的) のアップグレードでは、CorDappの異なるバージョンのノードが相互に取引を行うことができます。例えば、ノードAとノードBの両方がCorDappのバージョン1で動作していたとします。新しいバージョン（バージョン2）がリリースされ、ノードAはアップグレードし、ノードBはバージョン1のままだったとします。この時点で、ノードBは、トランザクション内のコントラクト・アタッチメントがトランザクションで使用される制約を満たす限り、ノードAとの間でトランザクションを開始することができます。このアプローチでは、ネットワークやノードの管理者がアップグレードの計画を立てる際に、より柔軟に対応することができます。\nこれを実現するためには、ノードがトランザクションで提示されたコントラクトが信頼できるかどうかをどのように判断するかが重要な問題となります。\nContract Constraint Contract constraintは、着信したトランザクションのcontractが受け入れられるかどうかを決定するアプローチとみなすことができます。\nCordaでは、いくつかのタイプのconstraintがサポートされています:\n Hash constraint: この状態で使用できるアプリのバージョンは1つだけです。これにより、元のバージョンで作成されたStateを利用しながら、将来的にアプリがアップグレードされることを防ぎます。これは、explicit upgradeに使用されます。 Compatibility zone whitelisted (or CZ whitelisted) constraint: 互換性ゾーン演算子は、コントラクトクラス名で使用可能なバージョンのハッシュをリストアップします。 Signature constraint: 特定の鍵で署名されたどのバージョンのアプリでも使用できます。Corda 4以降のバージョンでは、アプリが署名されている場合、この方法がデフォルトで使用されます。 Always accept constraint: どのバージョンのアプリでも使用できます。これは安全ではありませんが、テストには便利です。  Cordaの公式ドキュメントによると、Hash constraintとCompatibility zone whitelisted constraintは、Signature constraintが実装される前の初期のCordaバージョンの名残です。.\nSignature Constraintを使ったアップグレード Contract アップグレード Corda 4では、CorDappが署名されている場合、デフォルトでSignature constraint が使用されます。キーは、CompositeKeyまたはシンプルなPublicKeyのいずれかです。着信トランザクションを処理する際、ノードはその中のcontract attachmentが、そのSignature constraintで指定された正しい署名者を持っているかどうかを確認します。\nノードが信頼していないcontract attachmentを使用するトランザクションを受信したが、同じコントラクトクラスと同じ署名を持つアタッチメントがノード上に存在する場合、ノードはそのcontractのコードを信頼しているかのように実行します。つまり、ノードは古いバージョンのCorDappを実行しているトランザクションを検証するために、すべてのバージョンのCorDappをアップロードする必要はなくなりました。代わりに、CorDappコントラクトの任意のバージョンがインストールされていれば十分です。\noutput stateを追加する際には、TransactionBuilderが適切な制約とattachmentを選択してくれます。そのため、ほとんどの場合、コード内で使用する制約の種類を指定することを気にする必要はありません。\nCorDappのアップグレードとは、基本的にCorDappを新しいバージョンのJARファイルで置き換えることを意味します。また、新しいバージョンがstateの既存の状態と互換性があるかどうかを確認するために、様々なことに注意する必要があります。例えば、あるstateに新しいフィールドが導入された場合、そのフィールドをNullableにすることで、古いバージョンのアプリで生成されたstateをデシリアライズする際に問題が発生しないようにします。\nここでは、Kotlinでの例です：\nフローアップグレード フローのアップグレードでは、異なるバージョンで動作しているノード間のトランザクションをどのように処理するかは、CorDapp 開発者がコントロールします。\nフローのアップグレードの際に考慮すべき主な点は、フローのバージョニングです。@InitiatingFlowアノテーションには、デフォルトで1となるバージョンプロパティが用意されています。このプロパティが重要なのは、相手がどのバージョンのフローを実行しているかを判断するのに役立ち、それに応じて正しいビジネスロジックが実行されるようにフローを実装できるからです。\n下記は、フローのバージョン番号を指定する例です：\n下記は、カウンターパーティのフローバージョンを取得する例です：\nBackward-compatibility（後方互換性） CorDappの構造は、2つの独立したモジュールに分割することが推奨されています。\n contracts.jarには、ステートとコントラクトロジックが格納されています。 workflow.jarにはフロー、サービス、その他のサポートライブラリが格納されています。  contracts.jarはトランザクションに添付され、ネットワーク内のノード間で送信されますが、その中のコードはノードがトランザクションを検証するために必要なデータ構造とスマートコントラクトロジックを定義しているからです。CorDappのすべてが1つのモジュールに入っていると、フローのコードは使われていないにもかかわらず、一緒に流されてしまいます。\nアップグレードは、コントラクトとワークフローの両方のモジュールの変更を伴うとは限りません。フローのビジネスロジックを変更する必要があるためにアップグレードが起こる場合もあれば、スマートコントラクトのコードを更新する必要がある場合もあります。コントラクトとワークフローの両方が変更される場合は、新バージョンのフローが旧バージョンのフローや旧バージョンのコントラクトと後方互換性があるかどうかを確認することが重要です。\nHash contractからSignature contractへの移行 これまでの議論では、すべてのステートが同じタイプの制約によって作成されるという前提で話を進めてきました。しかし、現在Hash contractを使用していて、今後Signature contractに変更しようとしている場合、元帳上の既存の状態をSignature contractを使用するように移行する必要があります。\nこの記事の範囲外ですが、このトピックに関するいくつかのリソースがありますので、参考にしてみてください：\n Unconstraint Signature Constraint Migration contract-constraint-migration in Corda Advanced Bootcamps  ","excerpt":"CorDappの開発において、アップグレードは避けられません。CorDappのライフサイクルの間に、バグフィックスやビジネス要件の変更による …","ref":"/docs/corda-4/developers/cordapp_development/signature-constraint/","title":"Signature Constraint"},{"body":"CorDappの開発において、アップグレードは避けられません。CorDappのライフサイクルの間に、バグフィックスやビジネス要件の変更によるアップデートがないことはほとんどありません。アップグレードは小さなものもあれば、大規模な計画を必要とする複雑な変更の場合もあります。いずれにしても、これは見過ごせないテーマです。\n読み進める前に、この記事はステート、フロー、コントラクトなどのCordaの主要な概念を基本的に理解していることを前提としています。これらを理解していなければ、この記事の残りの部分はあまり意味をなさないので、まずはそれらに慣れることをお勧めします。\nExplicitおよびImplicitなContractのアップグレード Cordaでは、アップグレードを管理する方法が2つあります:\n Explicit(明示的): すべてのノードで同じバージョンのコントラクトを持つCorDappsを動作させる必要があります。 Implicit(暗黙的): それぞれのノードが異なるタイミングでアップグレードできるようにすることで  Explicit(明示的) なアップグレードのコンセプトはとても簡単です。基本的にアップグレードが必要なときは、すべてのノードがそれを行う必要があります。Explicitアップグレードの欠点は、すべてのノードが、アップグレードされるコントラクトに属する元帳の既存の状態をすべて更新する必要があることです。これは重い処理になります。また、Cordaのような分散型台帳システムでは、すべてのノードに同時にアップグレードを要求することができない場合もあります。\n一方、Implicit(暗黙的) のアップグレードでは、CorDappの異なるバージョンのノードが相互に取引を行うことができます。例えば、ノードAとノードBの両方がCorDappのバージョン1で動作していたとします。新しいバージョン（バージョン2）がリリースされ、ノードAはアップグレードし、ノードBはバージョン1のままだったとします。この時点で、ノードBは、トランザクション内のコントラクト・アタッチメントがトランザクションで使用される制約を満たす限り、ノードAとの間でトランザクションを開始することができます。このアプローチでは、ネットワークやノードの管理者がアップグレードの計画を立てる際に、より柔軟に対応することができます。\nこれを実現するためには、ノードがトランザクションで提示されたコントラクトが信頼できるかどうかをどのように判断するかが重要な問題となります。\nContract Constraint Contract constraintは、着信したトランザクションのcontractが受け入れられるかどうかを決定するアプローチとみなすことができます。\nCordaでは、いくつかのタイプのconstraintがサポートされています:\n Hash constraint: この状態で使用できるアプリのバージョンは1つだけです。これにより、元のバージョンで作成されたStateを利用しながら、将来的にアプリがアップグレードされることを防ぎます。これは、explicit upgradeに使用されます。 Compatibility zone whitelisted (or CZ whitelisted) constraint: 互換性ゾーン演算子は、コントラクトクラス名で使用可能なバージョンのハッシュをリストアップします。 Signature constraint: 特定の鍵で署名されたどのバージョンのアプリでも使用できます。Corda 4以降のバージョンでは、アプリが署名されている場合、この方法がデフォルトで使用されます。 Always accept constraint: どのバージョンのアプリでも使用できます。これは安全ではありませんが、テストには便利です。  Cordaの公式ドキュメントによると、Hash constraintとCompatibility zone whitelisted constraintは、Signature constraintが実装される前の初期のCordaバージョンの名残です。.\nSignature Constraintを使ったアップグレード Contract アップグレード Corda 4では、CorDappが署名されている場合、デフォルトでSignature constraint が使用されます。キーは、CompositeKeyまたはシンプルなPublicKeyのいずれかです。着信トランザクションを処理する際、ノードはその中のcontract attachmentが、そのSignature constraintで指定された正しい署名者を持っているかどうかを確認します。\nノードが信頼していないcontract attachmentを使用するトランザクションを受信したが、同じコントラクトクラスと同じ署名を持つアタッチメントがノード上に存在する場合、ノードはそのcontractのコードを信頼しているかのように実行します。つまり、ノードは古いバージョンのCorDappを実行しているトランザクションを検証するために、すべてのバージョンのCorDappをアップロードする必要はなくなりました。代わりに、CorDappコントラクトの任意のバージョンがインストールされていれば十分です。\noutput stateを追加する際には、TransactionBuilderが適切な制約とattachmentを選択してくれます。そのため、ほとんどの場合、コード内で使用する制約の種類を指定することを気にする必要はありません。\nCorDappのアップグレードとは、基本的にCorDappを新しいバージョンのJARファイルで置き換えることを意味します。また、新しいバージョンがstateの既存の状態と互換性があるかどうかを確認するために、様々なことに注意する必要があります。例えば、あるstateに新しいフィールドが導入された場合、そのフィールドをNullableにすることで、古いバージョンのアプリで生成されたstateをデシリアライズする際に問題が発生しないようにします。\nここでは、Kotlinでの例です：\nフローアップグレード フローのアップグレードでは、異なるバージョンで動作しているノード間のトランザクションをどのように処理するかは、CorDapp 開発者がコントロールします。\nフローのアップグレードの際に考慮すべき主な点は、フローのバージョニングです。@InitiatingFlowアノテーションには、デフォルトで1となるバージョンプロパティが用意されています。このプロパティが重要なのは、相手がどのバージョンのフローを実行しているかを判断するのに役立ち、それに応じて正しいビジネスロジックが実行されるようにフローを実装できるからです。\n下記は、フローのバージョン番号を指定する例です：\n下記は、カウンターパーティのフローバージョンを取得する例です：\nBackward-compatibility（後方互換性） CorDappの構造は、2つの独立したモジュールに分割することが推奨されています。\n contracts.jarには、ステートとコントラクトロジックが格納されています。 workflow.jarにはフロー、サービス、その他のサポートライブラリが格納されています。  contracts.jarはトランザクションに添付され、ネットワーク内のノード間で送信されますが、その中のコードはノードがトランザクションを検証するために必要なデータ構造とスマートコントラクトロジックを定義しているからです。CorDappのすべてが1つのモジュールに入っていると、フローのコードは使われていないにもかかわらず、一緒に流されてしまいます。\nアップグレードは、コントラクトとワークフローの両方のモジュールの変更を伴うとは限りません。フローのビジネスロジックを変更する必要があるためにアップグレードが起こる場合もあれば、スマートコントラクトのコードを更新する必要がある場合もあります。コントラクトとワークフローの両方が変更される場合は、新バージョンのフローが旧バージョンのフローや旧バージョンのコントラクトと後方互換性があるかどうかを確認することが重要です。\nHash contractからSignature contractへの移行 これまでの議論では、すべてのステートが同じタイプの制約によって作成されるという前提で話を進めてきました。しかし、現在Hash contractを使用していて、今後Signature contractに変更しようとしている場合、元帳上の既存の状態をSignature contractを使用するように移行する必要があります。\nこの記事の範囲外ですが、このトピックに関するいくつかのリソースがありますので、参考にしてみてください：\n Unconstraint Signature Constraint Migration contract-constraint-migration in Corda Advanced Bootcamps  ","excerpt":"CorDappの開発において、アップグレードは避けられません。CorDappのライフサイクルの間に、バグフィックスやビジネス要件の変更による …","ref":"/docs/corda-5/developers/cordapp_development/signature-constraint/","title":"Signature Constraint"},{"body":"CorDappの開発において、アップグレードは避けられません。CorDappのライフサイクルの間に、バグフィックスやビジネス要件の変更によるアップデートがないことはほとんどありません。アップグレードは小さなものもあれば、大規模な計画を必要とする複雑な変更の場合もあります。いずれにしても、これは見過ごせないテーマです。\n読み進める前に、この記事はステート、フロー、コントラクトなどのCordaの主要な概念を基本的に理解していることを前提としています。これらを理解していなければ、この記事の残りの部分はあまり意味をなさないので、まずはそれらに慣れることをお勧めします。\nExplicitおよびImplicitなContractのアップグレード Cordaでは、アップグレードを管理する方法が2つあります:\n Explicit(明示的): すべてのノードで同じバージョンのコントラクトを持つCorDappsを動作させる必要があります。 Implicit(暗黙的): それぞれのノードが異なるタイミングでアップグレードできるようにすることで  Explicit(明示的) なアップグレードのコンセプトはとても簡単です。基本的にアップグレードが必要なときは、すべてのノードがそれを行う必要があります。Explicitアップグレードの欠点は、すべてのノードが、アップグレードされるコントラクトに属する元帳の既存の状態をすべて更新する必要があることです。これは重い処理になります。また、Cordaのような分散型台帳システムでは、すべてのノードに同時にアップグレードを要求することができない場合もあります。\n一方、Implicit(暗黙的) のアップグレードでは、CorDappの異なるバージョンのノードが相互に取引を行うことができます。例えば、ノードAとノードBの両方がCorDappのバージョン1で動作していたとします。新しいバージョン（バージョン2）がリリースされ、ノードAはアップグレードし、ノードBはバージョン1のままだったとします。この時点で、ノードBは、トランザクション内のコントラクト・アタッチメントがトランザクションで使用される制約を満たす限り、ノードAとの間でトランザクションを開始することができます。このアプローチでは、ネットワークやノードの管理者がアップグレードの計画を立てる際に、より柔軟に対応することができます。\nこれを実現するためには、ノードがトランザクションで提示されたコントラクトが信頼できるかどうかをどのように判断するかが重要な問題となります。\nContract Constraint Contract constraintは、着信したトランザクションのcontractが受け入れられるかどうかを決定するアプローチとみなすことができます。\nCordaでは、いくつかのタイプのconstraintがサポートされています:\n Hash constraint: この状態で使用できるアプリのバージョンは1つだけです。これにより、元のバージョンで作成されたStateを利用しながら、将来的にアプリがアップグレードされることを防ぎます。これは、explicit upgradeに使用されます。 Compatibility zone whitelisted (or CZ whitelisted) constraint: 互換性ゾーン演算子は、コントラクトクラス名で使用可能なバージョンのハッシュをリストアップします。 Signature constraint: 特定の鍵で署名されたどのバージョンのアプリでも使用できます。Corda 4以降のバージョンでは、アプリが署名されている場合、この方法がデフォルトで使用されます。 Always accept constraint: どのバージョンのアプリでも使用できます。これは安全ではありませんが、テストには便利です。  Cordaの公式ドキュメントによると、Hash constraintとCompatibility zone whitelisted constraintは、Signature constraintが実装される前の初期のCordaバージョンの名残です。.\nSignature Constraintを使ったアップグレード Contract アップグレード Corda 4では、CorDappが署名されている場合、デフォルトでSignature constraint が使用されます。キーは、CompositeKeyまたはシンプルなPublicKeyのいずれかです。着信トランザクションを処理する際、ノードはその中のcontract attachmentが、そのSignature constraintで指定された正しい署名者を持っているかどうかを確認します。\nノードが信頼していないcontract attachmentを使用するトランザクションを受信したが、同じコントラクトクラスと同じ署名を持つアタッチメントがノード上に存在する場合、ノードはそのcontractのコードを信頼しているかのように実行します。つまり、ノードは古いバージョンのCorDappを実行しているトランザクションを検証するために、すべてのバージョンのCorDappをアップロードする必要はなくなりました。代わりに、CorDappコントラクトの任意のバージョンがインストールされていれば十分です。\noutput stateを追加する際には、TransactionBuilderが適切な制約とattachmentを選択してくれます。そのため、ほとんどの場合、コード内で使用する制約の種類を指定することを気にする必要はありません。\nCorDappのアップグレードとは、基本的にCorDappを新しいバージョンのJARファイルで置き換えることを意味します。また、新しいバージョンがstateの既存の状態と互換性があるかどうかを確認するために、様々なことに注意する必要があります。例えば、あるstateに新しいフィールドが導入された場合、そのフィールドをNullableにすることで、古いバージョンのアプリで生成されたstateをデシリアライズする際に問題が発生しないようにします。\nここでは、Kotlinでの例です：\nフローアップグレード フローのアップグレードでは、異なるバージョンで動作しているノード間のトランザクションをどのように処理するかは、CorDapp 開発者がコントロールします。\nフローのアップグレードの際に考慮すべき主な点は、フローのバージョニングです。@InitiatingFlowアノテーションには、デフォルトで1となるバージョンプロパティが用意されています。このプロパティが重要なのは、相手がどのバージョンのフローを実行しているかを判断するのに役立ち、それに応じて正しいビジネスロジックが実行されるようにフローを実装できるからです。\n下記は、フローのバージョン番号を指定する例です：\n下記は、カウンターパーティのフローバージョンを取得する例です：\nBackward-compatibility（後方互換性） CorDappの構造は、2つの独立したモジュールに分割することが推奨されています。\n contracts.jarには、ステートとコントラクトロジックが格納されています。 workflow.jarにはフロー、サービス、その他のサポートライブラリが格納されています。  contracts.jarはトランザクションに添付され、ネットワーク内のノード間で送信されますが、その中のコードはノードがトランザクションを検証するために必要なデータ構造とスマートコントラクトロジックを定義しているからです。CorDappのすべてが1つのモジュールに入っていると、フローのコードは使われていないにもかかわらず、一緒に流されてしまいます。\nアップグレードは、コントラクトとワークフローの両方のモジュールの変更を伴うとは限りません。フローのビジネスロジックを変更する必要があるためにアップグレードが起こる場合もあれば、スマートコントラクトのコードを更新する必要がある場合もあります。コントラクトとワークフローの両方が変更される場合は、新バージョンのフローが旧バージョンのフローや旧バージョンのコントラクトと後方互換性があるかどうかを確認することが重要です。\nHash contractからSignature contractへの移行 これまでの議論では、すべてのステートが同じタイプの制約によって作成されるという前提で話を進めてきました。しかし、現在Hash contractを使用していて、今後Signature contractに変更しようとしている場合、元帳上の既存の状態をSignature contractを使用するように移行する必要があります。\nこの記事の範囲外ですが、このトピックに関するいくつかのリソースがありますので、参考にしてみてください：\n Unconstraint Signature Constraint Migration contract-constraint-migration in Corda Advanced Bootcamps  ","excerpt":"CorDappの開発において、アップグレードは避けられません。CorDappのライフサイクルの間に、バグフィックスやビジネス要件の変更による …","ref":"/docs/developers/cordapp_development/signature-constraint/","title":"Signature Constraint"},{"body":" こちらの記事はR3社のテックリードであるMike Wardによる記事の抄訳です。詳細については元記事をご覧ください。 R3社から、Corda4.6がもうすぐリリースされます。今回のリリースは、次の3つの領域に重点を置いています。\nFlow管理 メンバーシップとネットワークの改善 開発者向けの改善\n Flow管理 Cordaは、企業をまたいでワークフローを実現するFlowという機能を備えています。これらのワークフローの管理は困難な場合が多いです。今回のリリースでは，実行中のFlowの管理方法を改善しました。\n シェル/ RPCを介してFlowCheckpointを検索および検査する機能が追加されました。本番で長い時間使われるようになった結果、実行中のFlowを管理するツールが必要になりました。この機能を使用すると、Flowの開始時間、到達したステップ、渡されたパラメーターなど、実行中のFlowに関する豊富な情報をリモートで取得して、実行を管理することができます。これは、以前の「FlowHospital」を拡張しています。ユーザーはCorDappなどのいくつかのフィルター基準からFlowを照会し、進行状況等や各種の情報を取得できます。 Nodeを再起動せずにFlowを再試行できるようになりました。ノードオペレーターは、再試行をトリガーするためにノードを再起動する必要がなく、RPCを介してHospitalized Flowを再試行できるようになりました。さらに、ノードオペレーターは、問題のあるFlowを「再起動しない」としてマークし、ノードが再起動されたときに自動的に再試行されないようにすることができます。 一意のIDを使用して、フローの開始が重複しないようにすることができるようになりました。RPCクライアントがバージョンアップし、クライアントがFlowの二重呼び出しを排除できるようになりました。これにより、Flowの開始に失敗した場合にクライアントが適切なアクションを実行できるようになるため、エコシステム全体の回復力も向上します。   メンバーシップとネットワークの改善 多くの実運用経験によれば、CorDappオペレーターが参加者を管理する為に多くのコストを投じていることが判明しています。プライベートネットワークでも、the Corda Networkなどのより大きなネットワークでも、オペレーターはユーザーを特定し、それらの参加者について確立したメタデータを利用してユーザーを管理する必要があります。このニーズに対応するための初期機能を実装しました。\n ”代表”という参加者の実装。BNO（Business Network Operator)という用語がCordaにはあります。BNOとは、CorDappsをネットワーク参加者に配布し、ネットワークに参加したユーザーを管理する主体を表す用語です。この重要なエンティティがユーザーをより適切に管理できるようにすることを目指しました。手始めに，典型的にはBNOを表す「Primitive」を用意しました．今回のリリースでは、メンバーシップ認証のライフサイクルを管理するツールを紹介し、メンバーシップを管理し、資格を推進し、ビジネスネットワーク内でプライバシーとアクセス許可をきめ細かく設定するためのベストプラクティスを紹介します。 大規模ネットワークのサポート強化。ネットワークマップリストの配信パフォーマンスを向上させ、ネットワークが数千のノードを含む場合のターンアラウンドタイムを高速化しました。 Notaryを追加する際のFlag Dayの必要性の除去。新しいNotaryがネットワークのホワイトリストに追加されるたびに更新されたネットワークパラメーターを受け入れた後、Nodeをシャットダウンして再起動する必要がなくなりました。   開発者向けの改善 このリリースでは、開発者がより復元力のあるアプリケーションを構築するのに役立つ多くの改善がなされました。\n 復元できないチェックポイントの検出。Flowはその実行中に、自動的にシリアライズされ、チェックポイントに到達するたびにデシリアライズされるようになりました。これにより、デシリアライズできないチェックポイントを作成するフローコードの自動検出が可能になります。この機能は、運用中のノード構成では無効にすることができます。（主に開発中に使用することを想定しています） カスタムシリアライザーの登録を可能にしました。FlowCheckPointの一部として型をシリアル化するときに、カスタムシリアライザーを使用できるようになりました。（もちろん、ほとんどのクラスはカスタムシリアライザーを必要としません。）チェックポイントのシリアル化中に例外をスローするクラスの為の機能です。新しいCheckpointCustomSerializerインターフェイスを実装して、カスタムチェックポイントシリアライザーを作成できます。   その他の追加機能 上記3つの重点的な改善に加え、以下のような機能改善がなされています。\n Ledgerの統計データ提供。CordaのLedger（台帳）に関する統計を提供する新しいユーティリティCorDappをリリースします。 トランザクションチェーンのサイズ、添付ファイルの数、およびトランザクションチェーンのすべてのOutputが消費されたかどうかを示す情報が提供するLedgerGraphというユーティリティーが提供されます。このユーティリティは、トランザクションチェーンが長すぎる場合に，オペレーターがその動作を予測し、場合によっては他の手段を検討することを可能とします。 インプレースアップグレードの実現。CordaオープンソースからCordaエンタープライズに移行するお客様をよりよく支援したいと考えています。これに向けた最初のステップは、オープンソースとエンタープライズの間でスキーマが一致している事です。これにより、インスタンスの大規模な移行を必要としない、いわゆるインプレースアップグレードが可能になります。 署名件数カウントツールの改善。中央のコレクターNodeからCorda Enterpriseメータリングデータを取得できるようにMetering Cordappを改善しました。Metering CorDappはスタンドアローンクライアントになりました。クライアントをそのまま使用して、ビジネスネットワークの1つ以上のNodeからJSON形式で測定データを取得できます。各Nodeのシェルに直接アクセスする必要はありません。いずれかのNodeが応答に失敗した場合、クライアントは不足しているデータを収集する後続の試行を容易にします。 TLS鍵をHSMに保管できるようになりました。TLSキーは、他のCordaサーバーへの安全な接続を確保するために使用されます。これまでのリリースにもこの機能はありましたが、制限がありました。今回のリリースから、あらゆる構成において、HSMにTLSキーを保存できるようになりました。  ","excerpt":" こちらの記事はR3社のテックリードであるMike Wardによる記事の抄訳です。詳細については元記事をご覧ください。 R3社か …","ref":"/docs/understanding_corda/general_concepts/corda4.6-introduction/","title":"Corda 4.6 Introduction"},{"body":"","excerpt":"","ref":"/tags/privacy/","title":"privacy"},{"body":"Question Cordaを使って、データのプライバシーを確保するためにはどうしたら良いでしょうか？\nAnswer Transactionデータはピアツーピアベースで共有されるため、Cordaの台帳は最適にシャーディングされ、データは必要に応じて共有／保存されます。しかし、当事者は自分が直接参加者であるTransactionを受信するだけでなく、インプットステートのすべての過去のTransactionをトレースバックし、検証を実行する必要があります。これは特定のアセット・タイプにとってはプライバシー上の課題となる可能性がありますが、以下の機能により緩和することが可能です。\nConfidential identities 公開されているアイデンティティに加えて、必要に応じてノードは自分の秘密の署名アイデンティティを自己発行することができ、これを使用してTransactionのプライバシーを保護することができます。また、保護されたプライバシーを必要に応じて解除するための組み込みFlow（IdentitySyncFlow）もあります\nReissuing State アセットを償還したり再発行したりすることで、Transactionチェーンのサイズを小さくすることができる他、以前のアセット所有者のプライバシーを保護することも可能です。これは必要に応じて何度でも行うことができます。\nTransaction Tear off 認証のために第三者（例：Oracles）にトランザクションを送信する必要がある場合があります。そのような場合において、機密性の高い要素や無関係な要素を隠したい場合がありますが、TransactionのTier offを実施することが可能です。そうすることで、特定の要素を隠さずにデータを暗号化しつつ、後で変更できないことを保証しながら、検査や署名のためにTransactionを第三者に送ることができます。\nさらに、以下のようなプライバシー機能を積極的に開発しています。\nConclave ConclaveはR3が持つコンフィデンシャル・コンピューティングのソリューションです。セキュアなハードウェア・エンクレーブ内で契約検証を行うことで、台帳全体を効果的に暗号化することができます。すべての依存関係のある取引は、安全なハードウェア・エンクレーブの外部で暗号化されているため、当事者は過去の取引について何も知ることができません。\nゼロ知識証明 口座残高や取引金額の証明など、範囲証明のための暗号プリミティブを開発しました。\nMembership証明の設定 特定のMembershipに属しているか否かを事前にFlow内で確認し、当該Membershipに所属を確認できない場合、Txを送信しないという形でプライバシーを確保することが可能です。\n","excerpt":"Question Cordaを使って、データのプライバシーを確保するためにはどうしたら良いでしょうか？\nAnswer Transaction …","ref":"/docs/corda-4/faq/technology/privacy/","title":"データのプライバシー確保"},{"body":"Question Cordaを使って、データのプライバシーを確保するためにはどうしたら良いでしょうか？\nAnswer Transactionデータはピアツーピアベースで共有されるため、Cordaの台帳は最適にシャーディングされ、データは必要に応じて共有／保存されます。しかし、当事者は自分が直接参加者であるTransactionを受信するだけでなく、インプットステートのすべての過去のTransactionをトレースバックし、検証を実行する必要があります。これは特定のアセット・タイプにとってはプライバシー上の課題となる可能性がありますが、以下の機能により緩和することが可能です。\nConfidential identities 公開されているアイデンティティに加えて、必要に応じてノードは自分の秘密の署名アイデンティティを自己発行することができ、これを使用してTransactionのプライバシーを保護することができます。また、保護されたプライバシーを必要に応じて解除するための組み込みFlow（IdentitySyncFlow）もあります\nReissuing State アセットを償還したり再発行したりすることで、Transactionチェーンのサイズを小さくすることができる他、以前のアセット所有者のプライバシーを保護することも可能です。これは必要に応じて何度でも行うことができます。\nTransaction Tear off 認証のために第三者（例：Oracles）にトランザクションを送信する必要がある場合があります。そのような場合において、機密性の高い要素や無関係な要素を隠したい場合がありますが、TransactionのTier offを実施することが可能です。そうすることで、特定の要素を隠さずにデータを暗号化しつつ、後で変更できないことを保証しながら、検査や署名のためにTransactionを第三者に送ることができます。\nさらに、以下のようなプライバシー機能を積極的に開発しています。\nConclave ConclaveはR3が持つコンフィデンシャル・コンピューティングのソリューションです。セキュアなハードウェア・エンクレーブ内で契約検証を行うことで、台帳全体を効果的に暗号化することができます。すべての依存関係のある取引は、安全なハードウェア・エンクレーブの外部で暗号化されているため、当事者は過去の取引について何も知ることができません。\nゼロ知識証明 口座残高や取引金額の証明など、範囲証明のための暗号プリミティブを開発しました。\nMembership証明の設定 特定のMembershipに属しているか否かを事前にFlow内で確認し、当該Membershipに所属を確認できない場合、Txを送信しないという形でプライバシーを確保することが可能です。\n","excerpt":"Question Cordaを使って、データのプライバシーを確保するためにはどうしたら良いでしょうか？\nAnswer Transaction …","ref":"/docs/corda-5/faq/technology/privacy/","title":"データのプライバシー確保"},{"body":"Question Cordaを使って、データのプライバシーを確保するためにはどうしたら良いでしょうか？\nAnswer Transactionデータはピアツーピアベースで共有されるため、Cordaの台帳は最適にシャーディングされ、データは必要に応じて共有／保存されます。しかし、当事者は自分が直接参加者であるTransactionを受信するだけでなく、インプットステートのすべての過去のTransactionをトレースバックし、検証を実行する必要があります。これは特定のアセット・タイプにとってはプライバシー上の課題となる可能性がありますが、以下の機能により緩和することが可能です。\nConfidential identities 公開されているアイデンティティに加えて、必要に応じてノードは自分の秘密の署名アイデンティティを自己発行することができ、これを使用してTransactionのプライバシーを保護することができます。また、保護されたプライバシーを必要に応じて解除するための組み込みFlow（IdentitySyncFlow）もあります\nReissuing State アセットを償還したり再発行したりすることで、Transactionチェーンのサイズを小さくすることができる他、以前のアセット所有者のプライバシーを保護することも可能です。これは必要に応じて何度でも行うことができます。\nTransaction Tear off 認証のために第三者（例：Oracles）にトランザクションを送信する必要がある場合があります。そのような場合において、機密性の高い要素や無関係な要素を隠したい場合がありますが、TransactionのTier offを実施することが可能です。そうすることで、特定の要素を隠さずにデータを暗号化しつつ、後で変更できないことを保証しながら、検査や署名のためにTransactionを第三者に送ることができます。\nさらに、以下のようなプライバシー機能を積極的に開発しています。\nConclave ConclaveはR3が持つコンフィデンシャル・コンピューティングのソリューションです。セキュアなハードウェア・エンクレーブ内で契約検証を行うことで、台帳全体を効果的に暗号化することができます。すべての依存関係のある取引は、安全なハードウェア・エンクレーブの外部で暗号化されているため、当事者は過去の取引について何も知ることができません。\nゼロ知識証明 口座残高や取引金額の証明など、範囲証明のための暗号プリミティブを開発しました。\nMembership証明の設定 特定のMembershipに属しているか否かを事前にFlow内で確認し、当該Membershipに所属を確認できない場合、Txを送信しないという形でプライバシーを確保することが可能です。\n","excerpt":"Question Cordaを使って、データのプライバシーを確保するためにはどうしたら良いでしょうか？\nAnswer Transaction …","ref":"/docs/faq/technology/privacy/","title":"データのプライバシー確保"},{"body":"Question Corda Open Sourceを商用環境に使うことは可能でしょうか？ sadasdsa\nAnswer いいえ。\nCorda Enterpriseは商用版であり、Corda Open Sourceは公式製品サポートのつかないトライアル版です。\nCorda Open Sourceは誰でも無料でGithubから入手して、自由に利用することができますが、オープンソースソフトウェアなので、SBI R3 JapanまたはR3社の公式サポートを受けることができません\n商用利用する際のリスクは一般的に以下です。\n 障害発生時に公式製品サポートを利用することができないので、復旧に時間とコストがかかる、あるいは原因究明に至らない可能性がある アプリケーションのエンドユーザーがセキュリティー上の懸念を示す可能性がある サービスのリリース前判定（社内決済、社内セキュリティー・チェックリストのクリア）を通らない可能性がある  Corda Enterpriseを使うことで\n 公式の日本語製品サポート 迅速なパッチ提供 パフォーマンス向上（トランザクションの並行処理機能など） Corda Firewall 高可用性構成 が利用可能になります。  ","excerpt":"Question Corda Open Sourceを商用環境に使うことは可能でしょうか？ sadasdsa\nAnswer いいえ。 …","ref":"/docs/corda-4/faq/business/corda-open-source/","title":"Corda Open Sourceの商用環境への利用"},{"body":"Question Corda Open Sourceを商用環境に使うことは可能でしょうか？ sadasdsa\nAnswer いいえ。\nCorda Enterpriseは商用版であり、Corda Open Sourceは公式製品サポートのつかないトライアル版です。\nCorda Open Sourceは誰でも無料でGithubから入手して、自由に利用することができますが、オープンソースソフトウェアなので、SBI R3 JapanまたはR3社の公式サポートを受けることができません\n商用利用する際のリスクは一般的に以下です。\n 障害発生時に公式製品サポートを利用することができないので、復旧に時間とコストがかかる、あるいは原因究明に至らない可能性がある アプリケーションのエンドユーザーがセキュリティー上の懸念を示す可能性がある サービスのリリース前判定（社内決済、社内セキュリティー・チェックリストのクリア）を通らない可能性がある  Corda Enterpriseを使うことで\n 公式の日本語製品サポート 迅速なパッチ提供 パフォーマンス向上（トランザクションの並行処理機能など） Corda Firewall 高可用性構成 が利用可能になります。  ","excerpt":"Question Corda Open Sourceを商用環境に使うことは可能でしょうか？ sadasdsa\nAnswer いいえ。 …","ref":"/docs/corda-5/faq/business/corda-open-source/","title":"Corda Open Sourceの商用環境への利用"},{"body":"Question Corda Open Sourceを商用環境に使うことは可能でしょうか？ sadasdsa\nAnswer いいえ。\nCorda Enterpriseは商用版であり、Corda Open Sourceは公式製品サポートのつかないトライアル版です。\nCorda Open Sourceは誰でも無料でGithubから入手して、自由に利用することができますが、オープンソースソフトウェアなので、SBI R3 JapanまたはR3社の公式サポートを受けることができません\n商用利用する際のリスクは一般的に以下です。\n 障害発生時に公式製品サポートを利用することができないので、復旧に時間とコストがかかる、あるいは原因究明に至らない可能性がある アプリケーションのエンドユーザーがセキュリティー上の懸念を示す可能性がある サービスのリリース前判定（社内決済、社内セキュリティー・チェックリストのクリア）を通らない可能性がある  Corda Enterpriseを使うことで\n 公式の日本語製品サポート 迅速なパッチ提供 パフォーマンス向上（トランザクションの並行処理機能など） Corda Firewall 高可用性構成 が利用可能になります。  ","excerpt":"Question Corda Open Sourceを商用環境に使うことは可能でしょうか？ sadasdsa\nAnswer いいえ。 …","ref":"/docs/faq/business/corda-open-source/","title":"Corda Open Sourceの商用環境への利用"},{"body":"","excerpt":"","ref":"/tags/open-source/","title":"open source"},{"body":"","excerpt":"","ref":"/categories/","title":"Categories"},{"body":"","excerpt":"","ref":"/projects/","title":"Projects"},{"body":"","excerpt":"","ref":"/search/","title":"Search Results"},{"body":"","excerpt":"","ref":"/community/","title":"コミュニティ"}]